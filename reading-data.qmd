# Reading data from files {#sec-reading-data}

This chapter describes how to read footprinting data from `modBam` files
and other formats into R. It also introduces how the data is represented in
memory. [fmicompbio/footprintR]{.githubpkg} provides three functions for
reading data into R from specific file types: [readModBam]{.fn},
[readBedMethyl]{.fn} and [readModkitExtract]{.fn}. If you want to jump right
in, have a look at the documentation of the reader function corresponding to
the type of your data.

We start by loading the required packages and a `BSgenome` object providing
the mouse genome sequence.

```{r}
#| message: false

BSgenomeName <- "BSgenome.Mmusculus.GENCODE.GRCm39.gencodeM34"

library(footprintR)
library(BSgenomeName, character.only = TRUE)
library(SummarizedExperiment)
library(SparseArray)

# Load genome
gnm <- get(BSgenomeName)
genome(gnm) <- "mm39"
```

## Read-level versus summary-level

Typically, single molecule footprinting data at the single read level is stored
in `modBam` files, which are standard `bam` files (@Li2009-kl) that in
addition to the usual information on alignments also contain base
modifications encoded in the `ML` and `MM` tags (see section 1.7 of
[SAMtags.pdf](https://samtools.github.io/hts-specs/SAMtags.pdf) for details).

[readModBam]{.fn} reads `modBam` files and can either keep the data at the level
of individual reads or summarize them per genomic position and sample.

## Data representation {#sec-data-representation}

Let's start by reading individual reads from a `modBam` file for a small
region of the genome:

```{r}
se <- readModBam(
    bamfiles = c(wt1 = "data/mESC_wt_6mA_rep1.bam",
                 wt2 = "data/mESC_wt_6mA_rep2.bam"),
    modbase = "a", 
    regions = "chr8:39286000-39286200", 
    seqinfo = seqinfo(gnm), 
    sequenceContextWidth = 1, 
    sequenceReference = gnm,
    trim = TRUE
)
se
```

Here is a scheme that illustrates the internals of `se` containing read-level
data:
![](images/se-read-level.png){.lightbox fig-alt="SummarizedExperiment with read-level data in assays." height=300}

Let's go through the individual parts.
You can see that the data is contained in a `RangedSummarizedExperiment` object.
This is a container that contains one or more assays (here only one assay
called `mod_prob`). Each assay is a matrix-like object and contains the
loaded data (here: base modification probabilities of individual reads).
```{r}
assayNames(se)
```

The rows represent genomic positions and the columns represent samples. In our
example, we have loaded data from two `modBam` files corresponding to the two
samples `"wt1"` and `"wt2"`, thus the object has two columns:
```{r}
ncol(se)
colnames(se)
```

The `r nrow(se)` rows correspond to individual base positions, for which at
least one modification has been loaded. You can get the genomic coordinates of
these positions using `rowRanges`:
```{r}
nrow(se)
rowRanges(se)
```

These positions are stranded, as base modifications can be observed on either
of the two strands:
```{r}
table(strand(se))
```

Finally, the individual reads of a sample are stored in the assay, inside the
"column" of that sample:
```{r}
assayNames(se)
assay(se, "mod_prob")
```

You can see that each column is itself an object of type `NaMatrix`.
```{r}
# get the NaMatrix with reads of sample wt1
mp1 <- assay(se, "mod_prob")$wt1
mp1
```

The rows in the `NaMatrix` corresponding to the same genomic positions we
have seen above, but the columns correspond to the `r ncol(mp1)` individual
reads. The numeric values correspond to modification probabilities. A value
greater than 0.5 or 0.7 is typically considered modified. Many values
are `NA` (missing), either because a read did not overlap a given position, or
there was no information about modifications at that position in that read.
Storing all these `NA` values would be a waste of memory, which is avoided
in the `NaMatrix`, which is a special type of sparse matrix from the
[SparseArray]{.biocpkg} package that only stores non-`NA` values.

## Flattening read-level to summary-level data

We can use [flattenReadLevelAssay]{.fn} to go from this read-level to
summary-level data:
```{r}
se_summary <- flattenReadLevelAssay(se)
```

Here is an illustration of the summary-level data container:
![](images/se-summary-level.png){.lightbox fig-alt="SummarizedExperiment with summary-level data in assays." height=300}
Its dimensions are identical to the original `se` (positions by samples),
however it contains additional assays that do not have the nested
structure with individual reads, but are simple matrices:
```{r}
dim(se_summary)
assayNames(se_summary)
head(assay(se_summary, "Nmod"))
```

By default, [flattenReadLevelAssay]{.fn} keeps the read-level assay
(`"mod_prob"`) and generates summarized assays with the
numbers of modified and total bases (`"Nmod" and "Nvalid"), and the
fraction of modified bases per position and sample (`"FracMod"`).

## Directly reading summary-level data

If the individual reads are not required, you can directly summarize
them while reading, which is faster and eliminates the call to
[flattenReadLevelAssay]{.fn}. This is achieved by adding the
argument `level = "summary"` to the [readModBam]{.fn} call:
```{r}
se_summary_direct <- readModBam(
    bamfiles = c(wt1 = "data/mESC_wt_6mA_rep1.bam",
                 wt2 = "data/mESC_wt_6mA_rep2.bam"),
    modbase = "a", 
    regions = "chr8:39286000-39286200", 
    seqinfo = seqinfo(gnm), 
    sequenceContextWidth = 1, 
    sequenceReference = gnm,
    trim = TRUE,
    level = "summary"
)
se_summary_direct
identical(assay(se_summary, "FracMod"),
          assay(se_summary_direct, "FracMod"))
```

## Read sampling {#sec-read-sampling}

In some cases, we may want to read a random set of reads from a `modBam` file,
for example to calculate average modification rates or quality statistics.
In such cases, reading data by genomic position is not optimal.

[readModBam]{.fn} provides a special reading mode for this, controlled by the
arguments `nAlnsToSample` and `seqnamesToSampleFrom`:
```{r}
se_sampled <- readModBam(
    bamfiles = c(wt1 = "data/mESC_wt_6mA_rep1.bam",
                 wt2 = "data/mESC_wt_6mA_rep2.bam"),
    modbase = "a", 
    seqinfo = seqinfo(gnm), 
    sequenceContextWidth = 1, 
    sequenceReference = gnm,
    nAlnsToSample = 20,
    seqnamesToSampleFrom = "chr19"
)
se_sampled
se_sampled$n_reads
```

For details of how to make the sampling reproducible even when using multiple
parallel threads, and why you might get a lower number of sampled reads than
requested, please look at the documenation of [readModBam]{.fn}.

## Reading from other file types

In addition to reading from `modBam` files, you can also read (summary-level)
data from `bedMethyl` files using [readBedMethyl]{.fn}, or from tabular
files created by `modkit` using [readModkitExtract]{.fn}. The arguments of
these reader functions are largely similar to the ones used for reading
`modBam` files.

```{r}
# read from bedMethyl
bmfile <- system.file("extdata", "modkit_pileup_1.bed.gz",
                      package = "footprintR")
se_bedmethyl <- readBedMethyl(
    fnames = bmfile,
    modbase = "m",
    seqinfo = seqinfo(gnm), 
    sequenceContextWidth = 3, 
    sequenceReference = gnm
)
se_bedmethyl

# read from a tabular file created by modkit
extrfile <- system.file("extdata", "modkit_extract_rc_5mC_1.tsv.gz",
                        package = "footprintR")
se_modkit <- readModkitExtract(
    fnames = extrfile,
    modbase = "m",
    filter = NULL,
    seqinfo = seqinfo(gnm), 
    sequenceContextWidth = 3, 
    sequenceReference = gnm
)
se_modkit
```
